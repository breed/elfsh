Content-type: text/html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of ERESI</TITLE>
</HEAD><BODY>
<H1>ERESI</H1>
Section: User commands (1)<BR>Updated: May 2007<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

ERESI - The ERESI Reverse Engineering Software Interface
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>elfsh  [</B><I>OPTIONS</I>]

<P>
<B>etrace [</B><I>OPTIONS</I>]

<P>
<B>e2dbg  </B><I>programtodebug</I>

<P>
<B>kernsh</B>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

The ERESI Reverse Engineering Software Interface is a unified reverse engineering framework for UNIX operating systems based on the Executable &amp; Linking Format (ELF) such as Linux, BSD, Solaris, IRIX, and BeOS. It has a command line interface that make it useful remotely, and can generate graph images from code analysis on demand. It has a real dedicated reverse engineering language that makes it scriptable and adaptable to the precise needs of the users. ERESI contains more than 10 innovative and exclusive features that turns it into an environment of choice for the instrumentation, analysis, debugging, tracing, hooking, or simply integrity checking and events logging of binary programs. ERESI is composed of ELFsh (the ELF shell), E2dbg (The Embedded ELF debugger) and Etrace (The Embedded ELF tracer). This documentation applies on all of the components. 
<A NAME="lbAE">&nbsp;</A>
<H2>OPTIONS</H2>

The ELF shell (part of ERESI) can take the following command line parameters:
<P>
<B><DL COMPACT>
<DT>-f<DD>
</B>

input file
<B><DT>-w<DD>
</B>

output file
<P>
<P>
Note that the command line is slightly different for E2dbg and Etrace which do
NOT take those parameters.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>COMMANDS</H2>

E2dbg and Etrace have to be executed using a unique command line parameter (the program file to be debugged or traced). The following primitives can be used interactively in E2dbg, Etrace, and ELFsh, but also on command line when preceded by a - (ELFsh only) at the UNIX shell command prompt.
<P>
<DL COMPACT>
<DT><B>General purpose commands</B><DD>
<P>
<I>cat edit exec exit help info list load lscripts nocolor profile quit sdir setcolor switch unload workspace</I>
<P>
<DT><B>cat</B><DD>
print the file argument
<P>
<DT><B>edit</B><DD>
Edit the file given in parameter
<P>
<DT><B>exec</B><DD>
Fork and execute parameter command (with args)
<P>
<DT><B>help</B><DD>
Print the help screen
<P>
<DT><B>info</B><DD>
Print the extra details help screen 
<P>
<DT><B>list</B><DD>
List the loaded files and their ID
<P>
<DT><B>load</B> <I>filename</I><DD>
Load input file <I>filename</I>
<P>
<DT><B>lscripts</B><DD>
List macro commands
<P>
<DT><B>nocolor</B><DD>
Toggle color status
<P>
<DT><B>profile</B> (<I>enable</I> | <I>disable</I>) (<I>traces</I> | <I>warns</I> | <I>alloc</I> | <I>debug</I> | <I>all</I>)<DD>
<P>
Change the ELFsh profiling behavior. Traces profiling print all the internal function calls done by the framework. Warning profiling prints all the (fatal and non-fatal) warnings reported by the internal API : it very useful for tracking bugs and it should be used when reporting issues on the bugtracking system. Allocation and debug profiling are experimental and should only be used by experienced ERESI developers.
<P>
<DT><B>quit</B><DD>
Quit the shell without saving
<P>
<DT><B>sdir</B><DD>
Change the script directory. This allows to make precise the location of complete ERESI library and bind script files on command names in the shell. 
<P>
<DT><B>setcolor</B> <I>Associates data types to colors</I><DD>
<P>
<B>setcolor</B> <I>type [bg,fg] color</I>
<P>
<B>setcolor</B> <I>type [underline,bold] (1=on,0=off)</I>
<P>
<B>Available types  :</B> <I>address, number, string, endstring, warnstring typestring, fieldstring, instr, pspecial, psname pspecial, pversion, prelease, pedition</I>
<P>
<B>Available colors :</B> <I>black red green yellow blue magenta cyan white</I>
<P>
<DT><B>switch</B> (<I>filename</I> | <I>fileID</I>)<DD>
Change the current file to work on to <I>filename</I> or <I>fileID</I>
<P>
<DT><B>unload</B> (<I>filename</I> | <I>fileID</I>)<DD>
Unload file <I>filename</I> or <I>fileID</I> without saving
<P>
<DT><B>workspace</B> [<I>wname</I>]<DD>
When executed without parameter, this command list existing workspaces. When given an existing workspace name, this command switch to that workspace. If given a non-existing workspace name, this command creates a new workspace and switch to it.
<P>
<DT><B>tables</B> [<I>regex</I>]<DD>
If given without parameter, list all the existing hash tables in the ERESI framework. If given with a parameter,
print the content of hash tables whoose name match the regular expression.
<P>
<P>
<DT><B>vectors</B> [<I>vname</I>[<I>:idx1:...:idxN</I>]] [<I>symbol|addr</I>]<DD>
If given without parameter, list all the existing vectors in the ERESI framework. If given with a parameter,
print the content of this vector. If given one long parameter, print the content of a given vector entry. If
given 2 parameters, modify the vector entry with a user provided address or resolved symbol address.
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>Ondisk/Memory ELF commands</B><DD>
<P>
Those commands works in all components of the ERESI framework (ELFsh, E2dbg, and Etrace).
<P>
<I>add cmp ctors disasm div dtors dyn dynsym elf findrel get got hexa interp mod mul notes pht print redir rel reladd set sht sub write test</I>
<P>
<DT><B>add</B><DD>
Add the 2 parameters and put the result in variable $_
<P>
<DT><B>cmp</B><DD>
Compare 2 parameters. The difference is put in variable $_
<P>
<DT><B>ct ctors</B> [<I>Regex</I>]<DD>
Print .ctors section entries matching <I>Regex</I>
<P>
<DT><B>D disasm</B> [<I>Regex</I>]<DD>
Disassemble matching binary objects in current file
<P>
<B>disasm parameter</B>
<P>
Allowed parameter format : <I>regx regx:rva regx:rva%size regx%size</I>
<BR>&nbsp;-&nbsp;regx&nbsp;:&nbsp;Regular&nbsp;expression&nbsp;(mandatory)
<BR>&nbsp;-&nbsp;rva&nbsp;&nbsp;:&nbsp;Byte&nbsp;offset&nbsp;from&nbsp;the&nbsp;beginning&nbsp;(optional)
<BR>&nbsp;-&nbsp;size&nbsp;:&nbsp;Bytes&nbsp;number&nbsp;limit&nbsp;(optional)
<P>
<DT><B>div</B><DD>
Divide first param by second one and put the result in the first one
<P>
<DT><B>dt dtors</B> [<I>Regex</I>]<DD>
Print .dtors section entries matching <I>Regex</I>
<P>
<DT><B>dyn</B><DD>
Print the ELF dynamic section
<P>
<DT><B>ds dynsym</B> [<I>Regex</I>]<DD>
Print dynamic symtab (.dynsym) entries matching <I>Regex</I>
<P>
<DT><B>e elf</B><DD>
Print the ELF header
<P>
<DT><B>findrel</B><DD>
Try to find back stripped relocation information. Note: retreiving this information in a
very exact manner is very difficult, this command only gives you an approximative list
of pointer accesses in the binary code. It does not deal either with constructed addresses
using multiple arithmetic and logic instructions, or with false positives that appear to
be valid mapped pointers but are not in reality (ex: Hashed data)
<P>
<DT><B>get</B><DD>
Print parameter object value. The parameter can be a constant or defined value, a variable or any
ELF object that is part of any file loaded in the shell, provided you give its id at the beginning
of the object path. See info command for the exact grammar of object paths. 
<P>
<DT><B>g got</B> [<I>Regex</I>]<DD>
Print the entries of the Global Offset Table (GOT) matching <I>Regex</I>. The regex can apply on
either an address, an entry index, or a resolved symbol from the entry address (or contained
address).
<P>
<DT><B>X hexa</B> [<I>Regex</I>]<DD>
Dump matching binary objects in current file. This has the same syntax than D/disasm command.
<P>
<B>X parameter</B>
<P>
ParamFormat : <I>regx regx:rva regx:rva%size regx%size</I>
<BR>&nbsp;-&nbsp;regx&nbsp;:&nbsp;Regular&nbsp;expression&nbsp;(mandatory)
<BR>&nbsp;-&nbsp;rva&nbsp;&nbsp;:&nbsp;Byte&nbsp;offset&nbsp;from&nbsp;the&nbsp;beginning&nbsp;(optional)
<BR>&nbsp;-&nbsp;size&nbsp;:&nbsp;Bytes&nbsp;number&nbsp;limit&nbsp;(optional)
<P>
<DT><B>interp</B><DD>
Print ELF interpreter path standing in .interp section.
<P>
<DT><B>mod</B><DD>
Modulo operation between 2 parameters. The result is put in the destination variable.
<P>
<DT><B>mul</B><DD>
Multiply the 2 parameters. The result is put in the destination variable.
<P>
<DT><B>n notes</B> [<I>Regex</I>]<DD>
Print the Notes sections entries matching <I>Regex</I>
<P>
<DT><B>p pht</B><DD>
Print the Program Header Table (PHT)
<P>
<DT><B>print</B> [<I>ObjectPath1 ObjectPath2 ... ObjectPathN</I>]<DD>
Print the values of objects <I>ObjectPath1 ObjectPath2 ... ObjectPathN</I>. Objects can be
constant strings, ELF objects, variables, defined values, and so on.
<P>
<DT><B>redir</B> <I>func</I> (<I>func2</I> | <I>addr</I>)<DD>
Redirect calls to function <I>func</I> to <I>func2</I> or address <I>addr</I>. If the original function has a PLT entry, the ALTPLT technique is used to perform the redirection. If the function is internal (or if we are in a static binary) the CFLOW technique is used to perform the redirection. ALTPLT technique is available on INTEL, SPARC, MIPS, and ALPHA  architectures. CFLOW technique is currently not available on the SPARC architecture. The hook (second) function is usually an injected C code provided by the user and injected using the <I>reladd</I> primitive. In case the provided hook function calls other function which are not in the host binary, ERESI will use the EXTPLT technique (or EXTSTATIC technique on static binaries) to relink the host binary in order to add new relocation entries, dynamic symbols with their names, symbol versions, extra GOT and PLT entries (using additionally the ALTGOT technique on RISC architectures), and will fixup the .dynamic section to reflect those changes on the section list.
<P>
<DT><B>r rel</B> [<I>Regex</I>]<DD>
Print the relocation entries matching <I>Regex</I>
<P>
<DT><B>reladd</B> (<I>DestFilePath | DestfileID</I>) (<I>RelocFilePath | RelocFileID</I>)<DD>
Inject the ELF relocatable object <I>RelocFileID</I> into the ELF executable object <I>DestFileID</I>. This command is used for injecting plain C compiled code linked into a .o file into a host ET_EXEC (executable) or ET_DYN (shared library) ELF file. 
<P>
<DT><B>set</B> <I>DestObjectPath SourceObjectPath</I><DD>
Set the value of object <I>DestObjectPath</I> to <I>SourceObjectPath</I>. The $_ variable gets modified depending on the result. See the <B>info</B> command for a list of all accessible objects using the set command.
<P>
<DT><B>s sht</B> [<I>Regex</I>]<DD>
Print the sections in the Section Header Table (SHT) matching <I>Regex</I>
<P>
<DT><B>sub</B><DD>
Substract 2nd parameter to the first one. The $_ variable is modified depending on the result.
<P>
<DT><B>write</B> <I>DestObjectPath SourceObjectPath</I><DD>
Copy data from <I>SourceObjectPath</I> to <I>DestObjectPath</I>. The destination object has to be of type RAW (the data field of a section) and the source object has to be of type RAW or STRING. See the info command for more detail about this.
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>Debugger commands</B><DD>
<P>
<I>backtrace break continue dbgstack delete dumpregs linkmap stack step display threads itrace</I>
<P>
<DT><B>backtrace</B><DD>
Print backtrace (needs frame pointer).
<P>
<DT><B>break (</B><I>BPsymbol</I> | <I>0xaddress</I>)<DD>
Put a breakpoint on symbol or address. Print all breakpoints if given without parameter.
<P>
<DT><B>step</B><DD>
<P>
Enable or disable stepping of debuggee program. Use <B>continue</B> for singlestepping.
<P>
<DT><B>continue</B><DD>
<P>
Continue executing debuggee program after breakpoint or singlestep.
<P>
<DT><B>delete</B> (<I>BPID</I> | <I>BPsymbol</I> | <I>0xaddress</I>)<DD>
<P>
Delete breakpoint by symbol, address, or ID.
<P>
<DT><B>dbgstack</B> <I>WordsNBR</I><DD>
<P>
Dump N words (N given as first parameter) from the debugger stack. We can do that because the debugger is embedded into the debuggee process.
<P>
<DT><B>stack</B> <I>WordsNBR</I><DD>
<P>
Dump <I>WordsNBR</I> words on debuggee stack.
<P>
<DT><B>dumpregs</B><DD>
<P>
Dump registers of debuggee at breakpoint or step.
<P>
<DT><B>linkmap</B><DD>
<P>
Print Linkmap list for the debuggee process.
<P>
<DT><B>display</B> <I>BPid</I> <I>Full_ERESI_command</I><DD>
Set a command to be executed on event. The first parameter must be the breakpoint id that correspond to the event. The ERESI command can be any valid ERESI command, including the sourcing of an ERESI script.
<P>
<DT><B>threads</B> [<I>ThreadID</I>]<DD>
If called without parameter, this command list existing threads in the debuggee process. If called with a thread ID parameter, the current thread is switched to the thread indicated by the ID.
<P>
<DT><B>itrace</B><DD>
Singlestep the debuggee program until next breakpoint event, printing all executed instructions until it stops.
<P>
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>ELFsh modules commands</B><DD>
<P>
<I>modhelp modload modunload</I>
<P>
<DT><B>modhelp</B> <I>ModuleFilePath</I><DD>
Print help for a loaded ERESI module.
<P>
<DT><B>modload</B> <I>ModuleFilePath</I><DD>
Load an ERESI module. The path has to be absolute or relative to the registered module path.
<P>
<DT><B>modunload</B> <I>ModuleFilePath</I><DD>
Unload an ERESI module. The path has to be absolute or relative to the registered module path.
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>ELF objects flags</B><DD>
<P>
<I>fixup shtrm sstrip</I>
<P>
<DT><B>fixup</B><DD>
Mark BSS section to be included in disk file. The BSS gets immediately fixed in the ELFsh internal descriptor
of the object.
<P>
<DT><B>shtrm</B><DD>
Mark Section Header Table as removed. The SHT will be removed only when the file is saved.
<P>
<DT><B>sstrip</B><DD>
Mark the Section Header Table (SHT) and Symbol Table (.symtab) as stripped. They will be removed only when the
file is saved.
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>Ondisk only ELF commands</B><DD>
<P>
Those commands only works in ELFsh, or in E2dbg when switched to the static mode using the mode command.
<P>
<I>append extend flush insert remove save stab sym</I>
<P>
<DT><B>append</B> <I>SectionName</I> <I>SourceObjectPath</I><DD>
Append the data of object <I>SourceObjectPath</I> to section <I>SectionName</I>
<P>
<DT><B>extend</B> <I>SectionName</I> <I>length</I><DD>
Extend section <I>SectionName</I> with <I>length</I> zero bytes
<P>
<DT><B>flush</B><DD>
Flush all injected .o files from current file.
<P>
<DT><B>insert</B><DD>
Inject new object (section, symbol, or program header) in current working file.
<P>
insert sect  name code|data|unmap [sz] [align]
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sym&nbsp;&nbsp;&nbsp;name&nbsp;value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[sz]
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phdr&nbsp;&nbsp;type&nbsp;vaddr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[sz]
<P>
<DT><B>remove</B><DD>
Remove ELF object (section, symbol, or program header) from current working file
<P>
remove sect name
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sym&nbsp;&nbsp;name
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phdr&nbsp;index
<P>
<DT><B>save</B> <I>filename</I><DD>
Dump current selected file to output file <I>filename</I>. This command writes a file on disk.
<P>
<DT><B>debug</B><DD>
Print unified debug format information for the current file.
<P>
<DT><B>st sym</B> [<I>Regex</I>]<DD>
Print the symtab (.symtab) entries matching <I>Regex</I>.
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>Kernsh modules commands</B><DD>
<P>
Those commands only works in Kernsh.
<P>
<DT><B>openmem</B><DD>
Open kernel memory and static kernel
<P>
<DT><B>closemem</B><DD>
Close kernel memory and static kernel
<P>
<DT><B>sct</B><DD>
Display the syscall table
<P>
<DT><B>idt</B><DD>
Display the interrupt descriptor table
<P>
<DT><B>gdt</B><DD>
Display the global descriptor table
<P>
<DT><B>alloc</B><DD>
Alloc contiguous kernel memory
<P>
<DT><B>free</B><DD>
Free contiguous kernel memory
<P>
<DT><B>alloc_nc</B><DD>
Alloc non contiguous kernel memory
<P>
<DT><B>free_nc</B><DD>
Free non contiguous kernel memory
<P>
<DT><B>kmodule</B><DD>
Handle kernel module
<P>
kmodule -l module : load a lkm
<P>
kmodule -u module : unload a lkm
<P>
kmodule -r module1 module2 moduleout : link module with another
<P>
kmodule -i module original_name evil_name : change lkm init (original_name) with another function (evil_name)
<P>
<DT><B>ksym</B><DD>
Get an address of a kernel symbol
<P>
<DT><B>kmd5</B> <I>sa output</I> | <I>sa:rva output</I> | <I>sa%rva%size output</I> | <I>sa%size output</I><DD>
Make a md5sum.
<P>
sa : Symbol or addr
<P>
rva : Byte offset form the beginning (optional)
<P>
size : Bytes number limit (optional) (if size is 0 or not put, we search the end of the function)
<P>
output : file output (optional)
<P>
<P>
<DT><B>kcmd5</B> <I>format</I> | <I>file</I> <DD>
Check a md5.
<P>
format : addr:mode:size:off:md5
<P>
file : filename
<P>
<P>
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>Type related primitives</B><DD>
<P>
Those primitives allow to define and habitate types in the ERESI meta-language:
<P>
<DT><B>type</B> [<I>regex</I>]<DD>
<P>
Print list of types (only those matching the regular expression if given in parameter).
<P>
<DT><B>type</B> <I>name</I> = <I>field1:type1</I> ... <I>fieldN:typeN</I><DD>
<P>
Define a new type in the ERESI meta-language. Predefined types include byte, short, int,
caddr, daddr, long, hash, vector, string, and raw.
<P>
<DT><B>typedef</B> <I>tname</I> <I>tname2</I><DD>
<P>
Copy and rename a type. Any modification on one of the types will <B>not</B> affect the other.
<P>
<DT><B>inform</B> <I>type</I> [<I>name</I> | <I>address</I>]<DD>
<P>
Make type <I>name</I> habitated by the variable standing at address <I>name</I>. If called with
a single type name parameter, the command list all variables that habitate this type. If given
2 parameters, the name is interpreted as a symbol pointing on a variable. Its address is resolved
and the type is informed about this variable. If only an address is given, its symbol is looked up
and the variable corresponding to the symbol is informed. If no symbol corresponds to this address,
a new one is created that points on the address, and the newly symbolic variable is informed.
<P>
<DT><B>uninform</B> <I>type</I> [<I>name</I>]<DD>
<P>
Uninform a given variable from a type. If no variable name is given, all variables previously
informed are removed from the type habitation.
<P>
<P>
<DT><B>========================================================================</B><DD>
<P>
<P>
<DT><B>Network commands</B><DD>
<P>
<I>connect disconnect net netkill netlist peerslist rcmd</I>
<P>
<DT><B>connect</B><DD>
Add a DUMP connection to given host
<P>
<DT><B>disconnect</B><DD>
Kill the DUMP connection from IP
<P>
<DT><B>net</B><DD>
Activate networking capabilities
<P>
<DT><B>netkill</B><DD>
Kill a network client by IP
<P>
<DT><B>netlist</B><DD>
List connected network clients
<P>
<DT><B>peerslist</B><DD>
List connected DUMP peers
<P>
<DT><B>rcmd</B><DD>
Execute a command on a remote machine
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>Available prefixes</B><DD>
<P>
<I>alert all quiet sort verb</I>
<P>
<DT><B>alert</B><DD>
Alert prefix : change alert regular expression
<P>
<DT><B>a all</B> <I>regex</I><DD>
Set a global regular expression. All commands which take a regular expression as a parameter will default to use this global regular expression.
<P>
<DT><B>quiet</B><DD>
Toggle quiet flag (do not print executed commands)
<P>
<DT><B>sort</B><DD>
Sorting prefix (use a -addr- or s -size-)
<P>
<DT><B>verb</B><DD>
Toggle verbose flag (undo the quiet flag)
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>Available Script jumps</B><DD>
<P>
A certain number of jumps construct are available:
<P>
<I>je jg jge jl jle jmp jne</I>
<P>
<DT><B>je</B><DD>
Jump on label if equal (use last cmp result)
<P>
<DT><B>jg</B><DD>
Jump on label if greater (use last cmp result)
<P>
<DT><B>jge</B><DD>
Jump on label if greater or equal (use last cmp result)
<P>
<DT><B>jl</B><DD>
Jump on label if lower (use last cmp result)
<P>
<DT><B>jle</B><DD>
Jump on label if lower or equal (use last cmp result)
<P>
<DT><B>jmp</B><DD>
Unconditional jump to script label
<P>
<DT><B>jne</B><DD>
Jump on label if nont equal (use last cmp result)
<P>
You might also consider using a <B>foreach</B> construct, which is not
described in this manual page. 
<P>
<DT><B>========================================================================</B><DD>
<P>
<DT><B>Available modules</B><DD>
<P>
<I>modflow modremap modtest</I>
<P>
<DT><B>modflow</B><DD>
Modflow is an ELFsh module designed to perform control flow analysis on ELF binaries
for detailed examples and usage see README in ELFsh/modules/modflow
<P>
<DT><B>modremap</B><DD>
Modflow is an ELFsh module designed to perform remapping sections in Elf binaries see ELFsh/modules/modremap for further details
<P>
<DT><B>modtest</B><DD>
Modtest is a ElFsh module designed to show the usage of adding new commands to ELFsh see ELFsh/modules/modtest for further details
<P>
<DT><B>========================================================================</B><DD>
<P>
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>OBJECT PATH FORMAT</H2>

This section explains how to access different objects in an ELF file. For most commands the object can also be a decimal or hexadecimal numbers. In this case the ObjectPath is the number.
<P>
<DL COMPACT>
<DT><B>ELF Header</B><DD>
filename.hdrfield
<P>
ELF header fields are :
<P>
<P>
<DT><B>magic</B><DD>
Magic number
<P>
<DT><B>class</B><DD>
File class
<P>
<DT><B>type</B><DD>
Object file type
<P>
<DT><B>machine</B><DD>
Architecture 
<P>
<DT><B>version</B><DD>
Object file version
<P>
<DT><B>entry</B><DD>
Entry point virtual address
<P>
<DT><B>phoff</B><DD>
Program header table file offset
<P>
<DT><B>shoff</B><DD>
Section header table file offset
<P>
<DT><B>flags</B><DD>
Processor-specific Flags
<P>
<DT><B>ehsize</B><DD>
Size of the ELF header in bytes
<P>
<DT><B>phentsize</B><DD>
Size of the program headers
<P>
<DT><B>shentsize</B><DD>
Size of the section headers
<P>
<DT><B>phnum</B><DD>
Number of program headers
<P>
<DT><B>shnum</B><DD>
Number of section headers
<P>
<DT><B>shstrndx</B><DD>
Section header string table index
<P>
<DT><B>pax_pageexec</B><DD>
PAX use paging based non-executable pages
<P>
<DT><B>pax_emultramp</B><DD>
PAX emulate trampolines 
<P>
<DT><B>pax_mprotect</B><DD>
PAX restrict mmap
<P>
<DT><B>pax_randmmap</B><DD>
PAX randomize mmap 
<P>
<DT><B>pax_randexec</B><DD>
PAX randomly map executable address
<P>
<DT><B>pax_segmexec</B><DD>
PAX use segmentation based non-executable pages
<P>
<DT><B>got/ctors/dtors tables</B><DD>
(filename | fileID).(got|ctors|dtors)[index]
<P>
In this command, the index can also be a symbol
name that corresponds to the requested GOT, CTORS, OR DTORS entry.
<P>
<DT><B>Program segment header table</B><DD>
(filename | fileID).pht[index].fi eld
<P>
Program segment header table entry fields are :
<P>
<DT><B>type</B><DD>
Segment type
<P>
<DT><B>offset</B><DD>
Segment file offset 
<P>
<DT><B>paddr</B><DD>
Segment physical address
<P>
<DT><B>vaddr</B><DD>
Segment virtual address
<P>
<DT><B>filesz</B><DD>
Segment size in file
<P>
<DT><B>memsz</B><DD>
Segment size in memory
<P>
<DT><B>flags</B><DD>
Segment flags
<P>
<DT><B>align</B><DD>
Segment alignment
<P>
<DT><B>Symbol/Dynamic symbol tables</B><DD>
(filename | fileID).(symtab|dynsym)[index].fi eld
<P>
Symbol/Dynamic symbol table entry fields are :
<P>
<DT><B>name</B><DD>
Symbol name
<P>
<DT><B>value</B><DD>
Symbol value
<P>
<DT><B>size</B><DD>
Symbol size
<P>
<DT><B>bind</B><DD>
Symbol binding
<P>
<DT><B>type</B><DD>
Symbol type
<P>
<DT><B>other</B><DD>
Symbol visibility
<P>
<P>
<DT><B>Dynamic section</B><DD>
(filename | fileID).dynamic[index].fi eld
<P>
The .dynamic section entry fields are :
<P>
<DT><B>val</B><DD>
Integer or address value
<P>
<DT><B>tag</B><DD>
Dynamic entry type
<P>
<DT><DD>
<P>
<B>Section header table</B>
(filename | fileID).sht[index].fi eld
<P>
The index can be the name of the section. Section Header Table entries fields are :
<P>
<DT><B>type</B><DD>
Section type
<P>
<DT><B>offset</B><DD>
Section Offset in ELF file
<P>
<DT><B>addr</B><DD>
Section Address
<P>
<DT><B>size</B><DD>
Section Size in bytes
<P>
<DT><B>link</B><DD>
Link to another section
<P>
<DT><B>info</B><DD>
Additional Info
<P>
<DT><B>align</B><DD>
Section Alignment
<P>
<DT><B>entsize</B><DD>
Entry size if section holds table
<P>
<DT><B>flags</B><DD>
<DL COMPACT><DT><DD>
<P>
<DL COMPACT>
<DT>a<DD>
Section occupies memory during execution
<P>
<DT>w<DD>
Section is Writeable
<P>
<DT>x<DD>
Section is Executable
<P>
<DT>s<DD>
Contains nul-terminated strings
<P>
<DT>m<DD>
Section might be merged
<P>
<DT>l<DD>
Preserve order after combining
<P>
<DT>o<DD>
OS specific
<P>
<P>
<DT><B>Relocation table</B><DD>
(filename | fileID).rel[indextable][indexentry].fi eld
<P>
Relocation entry fields are :
<P>
<DT><B>type</B><DD>
Relocation Type
<P>
<DT><B>sym</B><DD>
Relocation symbol index
<P>
<DT><B>offset</B><DD>
Address
<P>
<DT><DD>
<B>Additional sections information</B>
(filename | fileID).section[sectionindex].fi eld
<P>
The section object is not a real object of the binary, but a kind of
virtual one. It holds all the information about a section that do not stand
in the sectoin header table entries. Section fields are :
<P>
<DT><B>name</B><DD>
Section name
<P>
<DT><B>raw</B><DD>
Section Raw data
<P>
To access use following path format :
<P>
<DT>filename.section[index[:offset[%elemsize]]].raw<DD>
<P>
<P>
<P>
</DL>
</DL>
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>AUTHOR</H2>

ERESI was created by Julien Vanegue and developed by the ERESI team 
<P>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>&lt;team at eresi-project dot antispam org&gt;<BR>
<P>
The complete list of ERESI contributors can be found on the website:
<P>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><A HREF="http://www.eresi-project.org">http://www.eresi-project.org</A><BR>
<P>
This manual page was created by Julien Vanegue, from previous work on the ELFsh man page by Peter De Schrijver 
for the Debian GNU/Linux system. Additional improvements were made by stingduk for version 0.7.
<P>
<P>
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<A HREF="/cgi-bin/man/man2html?1+readelf">readelf</A>(1), <A HREF="/cgi-bin/man/man2html?1+objdump">objdump</A>(1), <A HREF="/cgi-bin/man/man2html?1+objcopy">objcopy</A>(1), <A HREF="/cgi-bin/man/man2html?1+gdb">gdb</A>(1), <A HREF="/cgi-bin/man/man2html?1+ltrace">ltrace</A>(1), <A HREF="/cgi-bin/man/man2html?1+strace">strace</A>(1)
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">OPTIONS</A><DD>
<DT><A HREF="#lbAF">COMMANDS</A><DD>
<DT><A HREF="#lbAG">OBJECT PATH FORMAT</A><DD>
<DT><A HREF="#lbAH">AUTHOR</A><DD>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 19:15:20 GMT, March 24, 2008
</BODY>
</HTML>
