#!evarista/evarista32

# This create on-demand the block instruction list in the eresi runtime

reflect $1

set $curblock $_
set $curaddr $curblock.vaddr

# Just debug printing
#inspect $curblock
#profile enable warn

# Start the transformation
foreach $instr in $hash[instrlists:$curaddr]

print Transforming instruction: $instr

rewrite $instr into

# indirect always branch without link
case instr_t(type:b, nb_op:1, op1(content:reg)) -> IndBranch(addr:$curaddr, dst:Reg(id:$instr.op1.baser), uflags:0)

# direct always branch (b, bp) 											
case instr_t(type:b, nb_op:1, op1(content:imm)) -> Branch(addr:$curaddr, dst:Immed($instr.op1.imm), uflags:0) 			 

# indirect conditional branch without link
# XXX lacks flag translation
case instr_t(type:cb, nb_op:1, op1(content:reg)) -> IndBranch(addr:$curaddr, dst:Reg(id:$instr.op1.baser), uflags:0)

# direct always branch (bcc, bpcc) 											
# XXX lacks flag translation
case instr_t(type:cb, nb_op:1, op1(content:imm)) -> Branch(addr:$curaddr, dst:Immed($instr.op1.imm), uflags:0)

# indirect call (op1 reg) 											
case instr_t(type:c, nb_op:1, op1(content:reg)) -> IndCall(addr:$curaddr, dst:Reg(id:$instr.op1.baser), uflags:0)			 

# direct call (op1 addr) 											
case instr_t(type:c, nb_op:1, op1(content:imm)) -> Call(addr:$curaddr, idest:Addr($instr.op1.imm), uflags:0)			 

# ta* (traps)
case instr_t(type:i) -> Interrupt(addr:$curaddr, Immed(val:$instr.op1.imm), uflags:0)	 

# ret, retl 									 		
case instr_t(type:r) -> Return(addr:$curaddr, Immed(val:$instr.op1.imm), uflags:0) 	 

# save 												
case instr_t(type:p) -> Prolog(addr:$curaddr, uflags:0) 				 

# restore 												
case instr_t(type:e) -> Epilog(addr:$curaddr, uflags:0)				 

# illtrap 										 			
case instr_t(type:s) -> Stop(addr:$curaddr, uflags:0)				 

# nop											 		
case instr_t(type:n) -> Nop(addr:$curaddr, uflags:0)				

# andcc,subcc,orcc,addcc,inccc,deccc (op2 = reg) 								 		
# XXX: lack flags translation
case instr_t(type:ar-wf, nb_op:3, op2(content:reg)) -> TernopR3(addr:$curaddr, dst(id:$instr.op1.baser), src1(id:$instr.op2.baser), src2(id:$instr.op3.baser), uflags:$instr.flags)  

# andcc,subcc,orcc,addcc,inccc,deccc (op2 = immed)	 							 		
# XXX: lack flags translation
case instr_t(type:ar-wf, nb_op:3, op2(content:imm)) -> TernopRI(addr:$curaddr, dst(id:$instr.op1.baser), isrc(val:$instr.op2.imm), rsrc(id:$instr.op3.baser), uflags:$instr.flags)  

# sllx,sll,srl,srlx,add,sub,or,xor,and,sdivx,udivx,sra,srax,mulx (op2 immed) 					 		
case instr_t(type:ar, nb_op:3, op2(content:imm)) -> TernopRI(addr:$curaddr, dst(id:$instr.op1.baser), isrc(val:$instr.op2.imm), rsrc(id:$instr.op3.baser), uflags:0)  

# sllx,sll,srl,srlx,add,sub,or,xor,and,sdivx,udivx,sra,srax,mulx (op2 reg)  						 	
case instr_t(type:ar, nb_op:3, op2(content:reg)) -> TernopR3(addr:$curaddr, dst(id:$instr.op1.baser), src1(id:$instr.op2.baser), src2(id:$instr.op3.baser), uflags:0)  

# clrx, clrh, clrb, clr (op1 = reg)  										 	
case instr_t(type:ar, nb_op:1, op1(content:reg)) -> AssignIR(addr:$curaddr, dst(id:$instr.op1.baser), src(val:0), uflags:0)		 

# clrx, clrh, clrb, clr (op1 = mem)  										 		
case instr_t(type:ar-wm, nb_op:1, op1(content:mem)) -> AssignIM(addr:$curaddr, dst(name:$instr.op1.name base(id:$instr.op1.baser), off(val:$instr.op1.imm)), isrc(val:0), uflags:0) 	 

# btog immed 														
case instr_t(type:ar, nb_op:2, op1(content:imm)) -> TernopRI(addr:$curaddr, dst:Reg(id:$instr.op2.baser), isrc:Immed(val:$instr.op1.imm), rsrc:Reg(id:$instr.op2.baser), uflags:0)

# btog register 												 		
case  instr_t(type:ar, nb_op:2, op1(content:reg)) -> TernopR3(addr:$curaddr, dst:Reg(id:$instr.op2.baser), src1:Reg(id:$instr.op1.baser), src2:Reg(id:$instr.op2.baser), uflags:0)	 

# ld,ldd,ldub,ldx,lduw,lduh,ldsw,ldsb  									 		
case instr_t(type:a-rm) -> AssignMR(addr:$curaddr, src(name:$instr.op1.name base(id:$instr.op1.baser), off(val:$instr.op1.imm)), dst(id:$instr.op2.baser), uflags:0)  

# st,stb,stw,sth,std,stx (src = reg)
case instr_t(type:a-wm, op1(content:reg)) -> AssignRM(addr:$curaddr, src(id:$instr.op1.baser), dst(name:$instr.op2.name base(id:$instr.op2.baser), off(val:$instr.op2.imm)), uflags:0)

# st,stb,stw,sth,std,stx (src = immed)
case instr_t(type:a-wm, op1(content:imm)) -> AssignIM(addr:$curaddr, src(val:$instr.op1.imm), dst(name:$instr.op2.name base(id:$instr.op2.baser), off(val:$instr.op2.imm)), uflags:0)

# bset (op1 immed) 																
case instr_t(type:bs, op1(content:imm)) -> BitSet(addr:$curaddr, src(val:$instr.op1.imm), dst(id:$instr.op2.baser), uflags:0)		 

# tst (implicit 2e operand = immed 0 !) 											 		
case instr_t(type:cmp, nb_op:1, op1(content:reg)) -> CmpRI(addr:$curaddr, snd(id:$instr.op1.baser), fst(val:0), uflags:0)				 

# cmp (op2 register)
case instr_t(type:cmp, nb_op:2, op1(content:reg), op2(content:reg)) -> CmpRR(addr:$curaddr, fst(id:$instr.op1.baser), snd(id:$instr.op2.baser), uflags:0)			 

# cmp (op2 immed) 										 		
case instr_t(type:cmp, nb_op:2, op1(content:reg), op2(content:imm)) -> CmpRI(addr:$curaddr, snd(id:$instr.op1.baser), snd(val:$instr.op2.imm), uflags:0)	 		 

# Defaultcase 													
default print Unsupported instruction at address $curaddr	 

endrwt

add $curaddr 4 

endfor

